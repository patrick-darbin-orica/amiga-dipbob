# Note this is a slightly modified and cut down variant of the protogen autogenerated protocol.py for use specifically
# with visualiser.py
#
# The protocol.py present up a directory is the original autogenerated version for use with helper.py

import struct
import serial


class PhysicalLayer(object):
    def __init__(self, port: str, baud: int):
        self.port = serial.Serial(port, baud)
        self.port.reset_input_buffer()

    def write(self, data):
        self.port.write(data)
        self.port.flushOutput()

    def read(self, num: int):
        return self.port.read(num)


class Protocol(object):
    def __init__(self, phy: PhysicalLayer):
        self.commands = {
            'cycle': struct.pack('>B', 0),
            'set_ascent_rate': struct.pack('>B', 1),
            'set_descent_rate': struct.pack('>B', 2),
            'set_timeout': struct.pack('>B', 3),
            'set_ramp_rate': struct.pack('>B', 4),
            'get_ascent_rate': struct.pack('>B', 5),
            'get_descent_rate': struct.pack('>B', 6),
            'get_timeout': struct.pack('>B', 7),
            'get_ramp_rate': struct.pack('>B', 8),
            'get_previous_level': struct.pack('>B', 9),
            'send_motor_up': struct.pack('>B', 10),
            'send_motor_down': struct.pack('>B', 11),
            'send_motor_stop': struct.pack('>B', 12)
        }
        self.variables = {'uint8': {'packing': '>B', 'length': 1}, 'uint16': {'packing': '>H', 'length': 2},
                          'uint32': {'packing': '>I', 'length': 4}, 'int8': {'packing': '>b', 'length': 1},
                          'int16': {'packing': '>h', 'length': 2}, 'int32': {'packing': '>i', 'length': 4},
                          'bool': {'packing': '>B', 'length': 1}}

        self.phy = phy

    def execute_cycle(self):
        self.phy.write(self.commands['cycle'])
        buf = []
        val = b''
        # At end of DMA transfer 0xFFFF will be sent
        while val != b'\xFF\xFF':
            val = self.phy.read(2)
            buf.append(val)

        tension = []
        count = []

        # Unpack data and convert back into tension and line encoder data
        for val in buf[:-1]:
            raw_num = struct.unpack('>h', val)[0]
            tension.append((raw_num & (~0x2)) * (360.0/65536))  # Mask bits for tension, convert to degrees
            count.append(1 if raw_num & 0x2 else 0)  # Mask bit for line count encoder

        return {'tension': tension, 'count': count}

    def execute_set_ascent_rate(self, val: int):
        data = self.commands['set_ascent_rate'] + struct.pack(self.variables['uint8']['packing'], val)
        self.phy.write(data)

    def execute_set_descent_rate(self, val: int):
        data = self.commands['set_descent_rate'] + struct.pack(self.variables['uint8']['packing'], val)
        self.phy.write(data)

    def execute_set_timeout(self, quadrant: int, val: int):
        data = self.commands['set_timeout'] + struct.pack(self.variables['uint8']['packing'], quadrant) + \
               struct.pack(self.variables['uint16']['packing'], val)
        self.phy.write(data)

    def execute_set_ramp_rate(self, val: int):
        data = self.commands['set_ramp_rate'] + struct.pack(self.variables['uint16']['packing'], val)
        self.phy.write(data)

    def execute_get_ascent_rate(self):
        self.phy.write(self.commands['get_ascent_rate'])
        return_data = self.phy.read(1 * self.variables['uint8']['length'])
        return struct.unpack(self.variables['uint8']['packing'], return_data)[0]

    def execute_get_descent_rate(self):
        self.phy.write(self.commands['get_descent_rate'])
        return_data = self.phy.read(1 * self.variables['uint8']['length'])
        return struct.unpack(self.variables['uint8']['packing'], return_data)[0]

    def execute_get_timeout(self, val: int):
        data = self.commands['get_timeout'] + struct.pack(self.variables['uint8']['packing'], val)
        self.phy.write(data)
        return_data = self.phy.read(1 * self.variables['uint16']['length'])
        return struct.unpack(self.variables['uint16']['packing'], return_data)[0]

    def execute_get_ramp_rate(self):
        self.phy.write(self.commands['get_ramp_rate'])
        return_data = self.phy.read(1 * self.variables['uint16']['length'])
        return struct.unpack(self.variables['uint16']['packing'], return_data)[0]

    def execute_get_previous_level(self):
        self.phy.write(self.commands['get_previous_level'])
        return_data = self.phy.read(2 * self.variables['uint16']['length'])
        return [x[0] for x in struct.iter_unpack(self.variables['uint16']['packing'], return_data)]
    
    def send_motor_up(self):
        self.phy.write(self.commands['send_motor_up'])
        
        
    def send_motor_down(self):
        self.phy.write(self.commands['send_motor_down'])
        
    def send_motor_stop(self):
        self.phy.write(self.commands['send_motor_stop'])
